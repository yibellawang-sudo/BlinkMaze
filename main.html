<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blink Maze</title>
<style>
  :root {
    --bg: black;
    --panel: rgba(255, 255, 255, 0.04);
    --accent: #8ef;
    --pink: #f6a;
    --muted: rgba(255, 255, 255, 0.75)
  }
  html,body{
    height:100%;
    margin:0;
    background:black;
    color:#fff;
    font-family:Inter,system-ui,Arial,sans-serif
  }
  .wrap {
    max-width:1200px;
    margin:18px auto;
    text-align:center;
    padding: 0 12px;
  }
  h1 {
    margin: 8px 0 12px;
    font-weight: 600;
  }
  @font-face {
    font-family: "CCOverbyteOff";
    src: url("fonts/CCOverbyteOff.ttf") format("truetype");
    font-weight: normal;
    font-style: normal;
  }
  @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

  .title {
    font-family: "CCOverbyteOff", monospace;
    font-size: 64px;
    letter-spacing: 2px;
    text-align: center;
    image-rendering: pixelated;
    text-shadow:
      1px 0 #fff,
      -1px 0 #fff,
      0 1px #fff,
      0 -1px #fff;
    display: inline-block;
    position: relative;
  }

  #gameCanvas{
    display: block;
    background:var(--bg);
    margin:0 auto;
    border:3px solid #fff; 
    image-rendering: pixelated;
  }
  #status{
    margin-top: 12px;
    font-size: 15px;
    color: var(--muted);
  }
  .overlay {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(180deg, rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.8));
    z-index: 50;
  }
  .card {
    width: min(760px, 94%);
    background: rgba(255, 255, 255, 0.2);
    padding: 20px;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.06);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
    text-align: left;
    color: #fff;
  }
  .card h2 {
    margin: 0 0 8px;
  }
  .rule {
    margin: 12px 0;
    font-size: 12px; 
    line-height: 1.45; 
    color: #ddd;
  }
  .btn {
    background: var(--accent);
    color: #031018;
    border: none;
    padding: 10px 14px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 700;
  }
  .btn.secondary {
    background: transparent;
    color: #fff;
    border: 1px solid rgba(255, 255, 255, 0.06);
  }
  .popup-backdrop{
    position:fixed; 
    inset:0; 
    display:flex; 
    align-items:center; 
    justify-content:center;
    background:linear-gradient(90deg, rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.75));
    z-index: 60;
  }
  .popup{
    width: min(520px, 92%); 
    background: rgba(10, 10, 12, 0.96); 
    border:1px solid rgba(255, 255, 255, 0.06);
    padding:20px; 
    border-radius:12px; 
    box-shadow: 0 10px 40px rgba(0,0,0,0.8);
    color:#fff; 
    text-align:left;
  }
  .popup h3{
    margin: 0 0 8px; 
  }
  .popup .row{
    display: flex;
    justify-content: space-between;
    margin:8px 0;
  }
  .explain {
    background: linear-gradient(90deg, rgba(142, 230, 255, 0.03), rgba(246, 170, 255, 0.02));
    padding: 10px;
    border-radius: 8px;
    margin-top: 12px;
    color: #eaf;
  }
  .small {
    font-size: 13px;
    color: #ddd;
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1 class="title" id="gameTitle">Blink Maze</h1>
    <canvas id="gameCanvas" width="800" height="520"></canvas>
    <div id="status">Use arrow keys / WASD. Walls blink ‚Äî memorize them and reach the glow exit.</div>
  </div>

  <div id="introOverlay" class="overlay" style="display:flex;">
    <div class="card">
      <div id="introText"></div>
      <div style="display:flex; gap: 12px; justify-content: flex-end; margin-top: 12px;">
        <button id="skipBtn" class="btn secondary">Just Load Game</button>
      </div>
    </div>
  </div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha:false });
  const statusEl = document.getElementById('status');
  const introOverlay = document.getElementById('introOverlay');
  const startBtn = document.getElementById('startBtn');
  const skipBtn = document.getElementById('skipBtn');
  const instructions = [
    "Welcome to Blink Maze!",
    "The maze walls will only flash briefly...",
    "Move with WASD or the arrow keys!",
    "If you hit a wall, you'll be sent back to the start.",
    "Starting lvl 5, GLOWFRUITS will appear! Eating them will light up the walls around you~",
    "Needless to say, each level gets harder...are you ready?"
  ];
  const introText = document.getElementById('introText');
  let currentLine = 0;
  let typing = false;
  let startBtnCreated = false;

  function typeLine(line, callback) {
    typing = true;
    const p = document.createElement('p');
    p.className = 'introLine';
     p.style.fontFamily = '"VT323", monospace';
    introText.appendChild(p);
    let i = 0;
    const interval = setInterval(() => {
      p.textContent += line[i];
      i++;
      if (i >= line.length) {
        clearInterval(interval);
        typing = false;
        callback?.();
      }
    }, 40);
  }
  function showNextIntroLine() {
    if (typing) return;
    if(currentLine < instructions.length) {
      typeLine(instructions[currentLine], () => {});
      currentLine++;
      if(currentLine === instructions.length && !startBtnCreated) {
        const startBtn = document.createElement('button');
        startBtn.id = 'startBtn';
        startBtn.className = 'btn';
        startBtn.textContent = 'Start Game';
        startBtn.onclick = () => { 
          introOverlay.style.display='none';
          init();
        };
        introText.parentElement.appendChild(startBtn);
        startBtnCreated = true;
      } 
    }
  }
  introOverlay.addEventListener('click', () => {
    showNextIntroLine();
  });
  skipBtn.onclick = () => {
    introOverlay.style.display = 'none';
    init();
  };
  showNextIntroLine();

  const gameTitle = document.getElementById('gameTitle');
  let frame = 0;
  function animateTitleRetro() {
    frame++;
    const jitterX = Math.sin(frame * 0.2) * 2 + (Math.random() - 0.5) * 2;
    const jitterY = Math.sin(frame * 0.1) * 3 + (Math.random() - 0.5) * 2;
    gameTitle.style.transform = `translate(${jitterX}px, ${jitterY}px)`;

    requestAnimationFrame(animateTitleRetro);
  }

  animateTitleRetro();

  let rows = 14, cols = 18;
  let tileSize = 36;
  let baseRows = 14, baseCols = 18;
  let level = 1, maxLevels = 10;
  let maze = [];
  let player = { x:1, y:1, glowing:false };
  let exit = { x:1, y:1 };
  let glowfruits = []; // array of {x,y}
  let visible = true;
  let startTime = Date.now();
  let bestTimes = JSON.parse(localStorage.getItem('blinkMazeBest') || '{}');

  let invisibleDuration = 1000; // ms: time walls are hidden
  let visibleDuration = 1000; // ms: time walls are visible
  let blinkExtraGap = 400; // extra gap to avoid immediate toggles
  let blinkHandle = null;
  let gamePaused = false;
  let glowRevealRadius = 3; // tiles radius revealed when glowing

  /* Utility helpers */
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]] } return arr; }

  /* Responsive canvas sizing: fill viewport but leave margins for UI */
  function resizeCanvas(){
    const padW = 60;
    const padH = 140;
    const maxW = Math.min(window.innerWidth - padW, 1200);
    const maxH = Math.min(window.innerHeight - padH, 900);
    // Keep aspect ratio near 4:3 or use available shape
    // We'll set canvas to fill maxW x maxH but choose tileSize based on rows/cols
    canvas.width = maxW;
    canvas.height = maxH;
    // adjust tile size later when generating maze so maze fills canvas
  }
  window.addEventListener('resize', ()=>{
    resizeCanvas();
    generateMaze();
  });

  function generateMaze(){
    const aspect = canvas.width / canvas.height;
    rows = Math.max(7, Math.floor(baseRows + level * 1.1));
    cols = Math.max(7, Math.floor(baseCols + Math.round(level * 1.1 * aspect)));

    tileSize = Math.floor(Math.min(canvas.width / cols, canvas.height / rows));

    tileSize = Math.max(16, tileSize);
    // create grid filled with walls
    maze = Array.from({length: rows}, ()=>Array(cols).fill(1));

    //2-step DFS
    function carve(x,y){
      maze[y][x] = 0;
      const dirs = shuffle([[1,0],[-1,0],[0,1],[0,-1]]);
      for(const [dx,dy] of dirs){
        const nx = x + dx*2, ny = y + dy*2;
        if(nx>0 && ny>0 && nx<cols-1 && ny<rows-1 && maze[ny][nx] === 1){
          maze[y+dy][x+dx] = 0;
          carve(nx,ny);
        }
      }
    }
    carve(1,1);

    // place exit bottom right
    exit = { x: clamp(cols-2, 2, cols-2), y: clamp(rows-2, 2, rows-2) };
    maze[exit.y][exit.x] = 0;

    // If not reachable, connect via randomized corridor
    if(!isReachable(1,1, exit.x, exit.y)){
      connectToExitRandomized();
    }

    // add extra openings to increase complexity with level
    addExtraOpenings(Math.min(8, Math.floor(level/2)));

    // place glowfruits 
    glowfruits = [];
    if(level > 5){
      let count = (level >= 10) ? 3 : (level >= 8 ? 2 : 1);
      let tries = 0;
      while(count > 0 && tries < 300){
        tries++;
        const gx = Math.floor(Math.random()*(cols-2))+1;
        const gy = Math.floor(Math.random()*(rows-2))+1;
        if(maze[gy][gx] === 0 && !(gx===1 && gy===1) && !(gx===exit.x && gy===exit.y) && !glowfruits.some(g=>g.x===gx&&g.y===gy)){
          glowfruits.push({x:gx,y:gy});
          count--;
        }
      }
    }

    // reset player position
    player = { x:1, y:1, glowing:false };
    startTime = Date.now();
    restartBlinkCycle();
  }

  //BFS reachability
  function isReachable(sx,sy,tx,ty){
    if(sx<0||sy<0||tx<0||ty<0) return false;
    const visited = Array.from({length:rows}, ()=>Array(cols).fill(false));
    const q = [{x:sx,y:sy}];
    visited[sy][sx] = true;
    for(let i=0;i<q.length;i++){
      const cur = q[i];
      if(cur.x === tx && cur.y === ty) return true;
      for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nx = cur.x + dx, ny = cur.y + dy;
        if(nx>=0 && ny>=0 && nx<cols && ny<rows && !visited[ny][nx] && maze[ny][nx]===0){
          visited[ny][nx] = true; q.push({x:nx,y:ny});
        }
      }
    }
    return false;
  }
  function floodReachable(sx,sy){
    const out = [];
    const visited = Array.from({length:rows}, ()=>Array(cols).fill(false));
    const q = [{x:sx,y:sy}]; visited[sy][sx] = true;
    for(let i=0;i<q.length;i++){
      const c = q[i]; out.push(c);
      for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nx = c.x + dx, ny = c.y + dy;
        if(nx>=0 && ny>=0 && nx<cols && ny<rows && !visited[ny][nx] && maze[ny][nx]===0){
          visited[ny][nx] = true; q.push({x:nx,y:ny});
        }
      }
    }
    return out;
  }

  function connectToExitRandomized(){
    const reachable = floodReachable(1,1);
    if(reachable.length === 0){
      // fallback
      for(let x=1;x<=exit.x;x++) maze[1][x]=0;
      for(let y=1;y<=exit.y;y++) maze[y][exit.x]=0;
      return;
    }
    let best = null, bestD = Infinity;
    for(const r of reachable){
      const d = Math.abs(r.x - exit.x) + Math.abs(r.y - exit.y);
      if(d < bestD){ bestD = d; best = r; }
    }
    if(!best) return;
    let cx = best.x, cy = best.y;
    maze[cy][cx] = 0;
    while(cx !== exit.x || cy !== exit.y){
      const dx = Math.sign(exit.x - cx);
      const dy = Math.sign(exit.y - cy);
      if(dx !== 0 && dy !== 0){
        if(Math.random() < 0.6) cx += dx; else cy += dy;
      } else if(dx !== 0) cx += dx;
      else if(dy !== 0) cy += dy;
      maze[cy][cx] = 0;
      // occasionally open neighbor for variety
      if(Math.random() < 0.25 && cx+1 < cols) maze[cy][cx+1] = 0;
      if(Math.random() < 0.25 && cy+1 < rows) maze[cy+1][cx] = 0;
    }
  }

  //Add extra openings to create loops
  function addExtraOpenings(n){
    for(let i=0;i<n;i++){
      const x = Math.floor(Math.random()*(cols-2))+1;
      const y = Math.floor(Math.random()*(rows-2))+1;
      if(maze[y][x] === 1){
        const adj = [[1,0],[-1,0],[0,1],[0,-1]].some(([dx,dy])=>{
          const nx = x+dx, ny = y+dy;
          return nx>=0 && ny>=0 && nx<cols && ny<rows && maze[ny][nx]===0;
        });
        if(adj && Math.random() < 0.6) maze[y][x] = 0;
      }
    }
  }

  function drawMaze(){
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        if(maze[y][x] === 1){
          let drawTile = false;
          if(visible) drawTile = true;
          else if(player.glowing){
            const dx = Math.abs(x - player.x), dy = Math.abs(y - player.y);
            if(Math.max(dx,dy) <= glowRevealRadius) drawTile = true;
          }
          if(drawTile){
            ctx.fillStyle = '#444';
            ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
          }
        }
      }
    }
  }
  function drawPlayer(){
    ctx.fillStyle = player.glowing ? '#7ff' : '#0ff';
    const ppad = Math.max(4, Math.floor(tileSize*0.12));
    const s = Math.max(2, tileSize - ppad*2);
    ctx.fillRect(player.x*tileSize + ppad, player.y*tileSize + ppad, s, s);
  }
  function drawExit(){
    ctx.fillStyle = '#7f7';
    const pad = Math.max(3, Math.floor(tileSize * 0.06));
    const s = Math.max(4, tileSize - pad*2);
    ctx.fillRect(exit.x*tileSize + pad, exit.y*tileSize + pad, s, s);
  }
  function drawGlowfruits(){
    for(const g of glowfruits){
      ctx.fillStyle = '#f6a';
      const pad = Math.max(4, Math.floor(tileSize * 0.14));
      const s = Math.max(2, tileSize - pad*2);
      ctx.fillRect(g.x*tileSize + pad, g.y*tileSize + pad, s, s);
    }
  }
  function drawHUD(){
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    const best = bestTimes['L'+level] ? bestTimes['L'+level].toFixed(1)+'s' : '--';
    ctx.fillStyle = '#fff';
    ctx.font = Math.max(12, Math.floor(tileSize*0.35)) + 'px monospace';
    ctx.fillText(`Level ${level}/${maxLevels}  |  Time: ${elapsed}s  |  Best: ${best}`, 10, 20);
  }

  function resetPlayer(msg){
    player.x = 1; player.y = 1; player.glowing = false;
    // increase invisibility but clamp
    invisibleDuration = Math.min(4000, invisibleDuration + 200);
    restartBlinkCycle();
    statusEl.textContent = msg;
  }
  function movePlayer(dx,dy){
    if(gamePaused) return;
    const nx = player.x + dx, ny = player.y + dy;
    if(nx < 0 || ny < 0 || nx >= cols || ny >= rows) return;
    if(maze[ny][nx] === 1){
      resetPlayer(`üíÄ You hit a wall! Back to start of Level ${level}.`);
      return;
    }
    // Walk over glowfruits
    player.x = nx; player.y = ny;
    for(let i = glowfruits.length - 1; i >= 0; i--){
      if(glowfruits[i].x === player.x && glowfruits[i].y === player.y){
        player.glowing = true;
        glowfruits.splice(i,1);
      }
    }
    // check exit
    if(player.x === exit.x && player.y === exit.y){
      const elapsed = (Date.now() - startTime)/1000;
      const key = 'L'+level;
      const prev = bestTimes[key];
      if(!prev || elapsed < prev){
        bestTimes[key] = elapsed;
        localStorage.setItem('blinkMazeBest', JSON.stringify(bestTimes));
        showLevelPopup(elapsed, bestTimes[key], true);
      } else {
        showLevelPopup(elapsed, prev, false);
      }
    }
  }

  //popup
  function showLevelPopup(elapsed, bestForLevel, isNewBest){
    gamePaused = true;
    const backdrop = document.createElement('div');
    backdrop.className = 'popup-backdrop';
    const pop = document.createElement('div');
    pop.className = 'popup';

    const heading = document.createElement('h3');
    heading.textContent = `Level ${level} complete!`;

    const rowTime = document.createElement('div');
    rowTime.className = 'row small';
    rowTime.innerHTML = `<div>Time</div><div><strong>${elapsed.toFixed(1)}s</strong></div>`;

    const rowBest = document.createElement('div');
    rowBest.className = 'row small';
    rowBest.innerHTML = `<div>Best</div><div><strong>${bestForLevel ? bestForLevel.toFixed(1)+'s' : '--'}</strong>${isNewBest ? ' ‚≠ê New Best!' : ''}</div>`;

    pop.appendChild(heading);
    pop.appendChild(rowTime);
    pop.appendChild(rowBest);

    if(level >= 4){
      const explanation = document.createElement('div');
      explanation.className = 'explain small';
      explanation.innerHTML = `<strong>Glowfruit:</strong> Eating a glowfruit makes your player glow and <em>reveals</em> nearby walls (a ${glowRevealRadius}-tile radius) while walls are invisible. Use it to re-learn corridors.`;
      pop.appendChild(explanation);
    }

    const btnRow = document.createElement('div');
    btnRow.style.marginTop = '14px';
    btnRow.style.display = 'flex';
    btnRow.style.justifyContent = 'flex-end';
    btnRow.style.gap = '10px';

    const keepBtn = document.createElement('button');
    keepBtn.className = 'btn secondary';
    keepBtn.textContent = 'Replay Level';
    keepBtn.onclick = ()=>{
      document.body.removeChild(backdrop);
      // replay same level
      player = { x:1, y:1, glowing:false };
      startTime = Date.now();
      gamePaused = false;
      statusEl.textContent = `Level ${level} ‚Äî replaying`;
    };

    const contBtn = document.createElement('button');
    contBtn.className = 'btn';
    contBtn.textContent = (level < maxLevels) ? 'Continue' : 'Finish';
    contBtn.onclick = ()=>{
      document.body.removeChild(backdrop);
      if(level < maxLevels){
        level++;
        startTime = Date.now();
        generateMaze();
        gamePaused = false;
        statusEl.textContent = `Level ${level} ‚Äî good luck!`;
      } else {
        // finished all levels
        const vals = Object.values(bestTimes);
        const total = vals.length ? vals.reduce((a,b)=>a+b,0).toFixed(1) : '0.0';
        const again = confirm(`üèÜ You finished all ${maxLevels} levels!\nTotal best time (sum of level bests): ${total}s\nRestart?`);
        if(again){
          level = 1; invisibleDuration = 1000; startTime = Date.now();
          generateMaze(); gamePaused = false; statusEl.textContent = 'Level 1 ‚Äî go!';
        } else {
          statusEl.textContent = 'Thanks for playing!';
          gamePaused = false;
        }
      }
    };

    btnRow.appendChild(keepBtn);
    btnRow.appendChild(contBtn);
    pop.appendChild(btnRow);

    backdrop.appendChild(pop);
    document.body.appendChild(backdrop);
  }

  //Blink cycle control
  function toggleVisibilityOnce(){
    visible = true;
    setTimeout(()=>{ visible = false; }, visibleDuration);
  }
  function startBlinkCycle(){
    if(blinkHandle) clearInterval(blinkHandle);
    toggleVisibilityOnce();
    blinkHandle = setInterval(()=>{ toggleVisibilityOnce(); }, visibleDuration + invisibleDuration + blinkExtraGap);
  }
  function restartBlinkCycle(){
    if(blinkHandle) clearInterval(blinkHandle);
    toggleVisibilityOnce();
    blinkHandle = setInterval(()=>{ toggleVisibilityOnce(); }, visibleDuration + invisibleDuration + blinkExtraGap);
  }

  function draw(){
    // clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const mazeW = tileSize * cols;
    const mazeH = tileSize * rows;
    const offsetX = Math.floor((canvas.width - mazeW) / 2);
    const offsetY = Math.floor((canvas.height - mazeH) / 2);

    ctx.save();
    ctx.translate(offsetX, offsetY);

    drawMaze();
    drawGlowfruits();
    drawExit();
    drawPlayer();
    ctx.restore();

    // HUD drawn in top-left
    ctx.fillStyle = '#fff';
    ctx.font = Math.max(12, Math.floor(tileSize*0.35)) + 'px monospace';
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    const best = bestTimes['L'+level] ? bestTimes['L'+level].toFixed(1)+'s' : '--';
    ctx.fillText(`Level ${level}/${maxLevels}  |  Time: ${elapsed}s  |  Best: ${best}`, 10, 24);
  }
  function loop(){
    if(!gamePaused) draw();
    requestAnimationFrame(loop);
  }

  document.addEventListener('keydown', e=>{
    if(gamePaused) return;
    if(e.key === 'ArrowUp' || e.key === 'w') movePlayer(0,-1);
    if(e.key === 'ArrowDown' || e.key === 's') movePlayer(0,1);
    if(e.key === 'ArrowLeft' || e.key === 'a') movePlayer(-1,0);
    if(e.key === 'ArrowRight' || e.key === 'd') movePlayer(1,0);
  });

  function init(){
    resizeCanvas();
    generateMaze();
    startBlinkCycle();
    loop();
  }

  startBtn.onclick = ()=>{
    introOverlay.style.display = 'none';
    init();
  };
  skipBtn.onclick = ()=>{
    introOverlay.style.display = 'none';
    init();
  };

  resizeCanvas();
</script>
</body>
</html>
<!---

